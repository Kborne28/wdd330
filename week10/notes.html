<!DOCTYPE html>
<html lang="en">

   <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta http-equiv="X-UA-Compatible" content="ie=edge">
      <title>Week 01</title>
      <link rel="stylesheet" href="main.css">
      <script src="main.js"></script>
  </head>

<body onload=showNav(1)>
  <nav id='nav'></nav>

           
            <title>Week 10 Notes</title>
         
         
       

         
    <h1>Week 10 Notes</h1>
  
    <h2>Notes from  MDN: Validating Forms and MDN: Using Fetch </h2>
    
    <body> 
      <div class = "note1">
    <p> 
        There are different requirements regarding form validation. Before a client can submit data to the server, it is important to ensure that <br>
        all required form controls are filled out, in the correct format. This is known as client-side form validation. This helps make sure that the data<br>
        submitted on the client side matches the requirements set in the different form controls. <br>
        <br>
        Client-side validation helps catch invalid data that the user can correct immediately. It allows the server to reject errors, and send it back to the<br>
        client to let them know that their data needs to be fixed. But this is not considered to be a security measure, just error checking.<br>
        <br>
        Different types of client-side form validation messages:<br>
        <ul class ="a">
            <li>"This field is required" : Meaning, you can't leave the text field blank</li>
            <li>"Please enter your phone number in the format (xxx)-xxx-xxxx" : Meaning, this field requires a specific format</li>
            <li>"Please enter a valid email address" : Meaning, the data you entered is not in the right email format.</li>
            <li>"Your password needs to be between 8 and 30 characters long and contain one uppercase letter, one symbol, and a number" : Meaning, a specific format is required</li>
        </ul>
        <br>
        <br>
        There are two different types of client-side form validation: <br>
        <ul class ="a">
            <li>Built-in form validation: uses HTML5 form validation features. Built-in form validation has better performance<br>
            than JavaScript, but it is not as customizable as JavaScript validation.  </li>
            <li>JavaScript validation : uses JavaScript that is completely customizable, but you need to create it all or use a library</li>
        </ul>

        <br>

        <h2>Built-in Validation</h2>
        <form>
            <div class="a"> 
            <label for="choose">Would you prefer PlayStation or Xbox?</label>
            <input id="choose" name="i_like" required pattern ="[Pp]layStation|[Xx]box ">
           </div>
           <div class="b">
               <label for ="number">How many consoles have you owned?</label>
               <input type="number" id="number" name="amount" value="1" min="1" max="10">
           </div>
           
            <button>Submit</button>
        </form>
    </p>
      </div>
      
      <div class = "note2">
    
<br><br>
<form>    
<p>
  <fieldset>
      <legend>Do you have a drivers license?<abbr title="This field is mandatory" aria-label="required">*</abbr></legend>
      <input type="radio" required name="driver" id="r1" value="yes"><label for="r1">Yes</label>
      <input type="radio" required name="driver" id="r2" value="no"><label for="r2">No</label>
  </fieldset>  
</p>
<p>
    <label for="n1">How old are you?</label>
    <input type="number" min="12" max="120" step="1" id="n1" name="age" 
        pattern="\d+">
</p>     

<p>
    <label for="t2">What's your e-mail address?</label>
    <input type="email" id="t2" name="email">

</p>
<p>
    <label for ="t3">Leave a short message!</label>
    <textarea id="t3" name="msg" maxlength="140" rows="5"></textarea>
</p>
<p>
    <button>Submit</button>
</p>
</form>

</div>
<br><br>

      <div class = "note3">

<h2>JavaScript Validation</h2>
<p>
    You must use JavaScript if you wnat to take control over the look and feel of native error messages or to deal with legacy browsers that do not support<br>
    HTML's Built-in form validation.<br>
    One way to do this is The Constraint Validation API. Most browsers support this, which consists of a set of methods and properties:<br>
    <ul class="a">
        <li>HTMLButtonElement : represents a button element</li>
        <li>HTMLFieldSetElement : represents a fieldset element</li>
        <li>HTMLInputElement : represents an input element</li>
        <li>HTMLOutputElement : represents an output element</li>
        <li>HTMLSelectElement : represents a select element</li>
        <li>HTMLTextAreaElement : represents a text area element</li>
    </ul>

    <br><br>
    The following properties are made available on the above elements:
    <ul class="a">
        <li>validationMessage</li>
        <li>validity</li>
        <li>validityState</li>
            <ul>
                <li>patternMismatch</li>
                <li>tooLong</li>
                <li>maxLength</li>
                <li>tooShort</li>
                <li>minlength</li>
                <li>rangeOverflow</li>
                <li>rangeUnderflow</li>
                <li>typeMismatch</li>
                <li>valid</li>
                <li>valueMissing</li>
            </ul>
        <li>checkValidity()</li>
        <li>setCustomValidity(message)</li>
         </ul>
    </ul>

    <form novalidate>
        <label for="mail">
            <span>Please enter an email address:</span>
            <input type="email" id="mail" name="mail" required minlength="8">
            <span class="error" aria-live="polite"></span>

        </label>
      </p>  
      <button>Submit</button>    
       </form>
    
   
      </div>
<br><br>

<h2>Using Fetch</h2>
<div class="note3">

    <p>
        The Fetch API provides a JavaScript interface for accessing and manipulating parts of the HTTP pipeline, such as requests and responses. <br>
        It also provides a global fetch() method that provices an easy, logical way to fetch resources asynchronously across the network.<br>
        This kind of functionality was previously achieved using XMLHttpRequest. Fetch provides a better alternative that can be easily used by other technologies such <br>
        as service workers. Fetch also provides a single logical place to define other HTTP-related concepts such as CORS and extensions to HTTP.<br>
        <br>
        The fetch speicification differs from jQuery.ajax() in the following ways:<br>
        <ul class ='a'>
        <li>The Promise returned from fetch() won't reject on HTTP error status even if the response is an HTTP 404 or 500.</li>
        <li>fetch() won't send cross-origin cookies unless you set the credentials that way.</li>
        </ul>
        Here is what a basic fetch request looks like:<br>
        fetch('http://example.com/movies.json')<br>
        .then(response => reponse.json())<br>
        .then(data => console.log(data));<br>
    
    </p>
</div>
      



</body>
</html>